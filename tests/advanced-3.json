{
    "lifetime": 30,
    "replicas": 5,
    "requests": 10,
    "mix" : 0.2,
    "drops" : 0.3,
    "end_wait" : 10,
    "tests" : {
        "benchmarks" : {
            "total_msgs"     : [1000, 3000, 4000],
            "failures"       : [1, 10, 100],
            "dupl#!/usr/bin/env python3\nimport copy\nimport json\nimport random\nimport select\nimport socket\nimport sys\nimport time\n\n# Your ID number\nmy_id = sys.argv[1]\n\n# The current Leader\ncurr_leader = \"FFFF\"\n\n# Request Buffer\nqueue = []\n# The election timeout\nelection_timeout = random.randint(150, 300)\n\n# Your votes\nvotesReceived = 1\n\n# States\nstates = ['follower', 'candidate', 'leader']\n\nFOLLOWER = states[0]\nCANDIDATE = states[1]\nLEADER = states[2]\n\n# Your state\nstate = FOLLOWER\n\n# Persistent State\n# latest term server has seen\ncurrentTerm = 0\n# candidateId that received vote in current term\nvotedFor = None\n# log entries\nlog = []\n\n# data store\ndata = {}\n\n# debugging state\nDEBUG = False\nDEBUG2 = False\n\n# Volatile state on all servers:\n# index of highest log entry known to be committed\ncommitIndex = 0\n# index of highest log entry applied to state machine\nlastApplied = 0\n\n# Volatile state on leaders:\n\n# The ID numbers of all the other replicas\nreplica_ids = sys.argv[2:]\n\n# index of the next log entry to send to that server\nnextIndex = {}\n\n# index of highest log entry known to be replicated on server\nmatchIndex = {}\n\n# pairs of unresponded get requests along with the matching commitIndex when they should be responded to\nunresponded_gets = []\n\n\n# Connect to the network. All messages to/from other replicas and clients will\n# occur over this socket\nsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\nsock.connect(my_id)\n\nelection_timeout_last = round(time.time() * 1000)\n\nheartbeat_last = round(time.time() * 1000)\n\nSELECT_WAIT_TIME = 0.001  # 1 millisecond\nTERMINATOR = b'}\\n'\nbuffer = b''\n\ndef warn(s):\n    print('\\033[91m' + s + '\\033[0m')\n\n\n# Receive\ndef recv_msgs():\n    global buffer, sock\n\n    fresh_buf = sock.recv(16384)\n\n    # is this sock shutting down?\n    if len(fresh_buf) == 0:\n        return None\n\n    buffer += fresh_buf\n\n    msgs = []\n    while TERMINATOR in buffer:\n        position = buffer.find(TERMINATOR) + len(TERMINATOR)\n        msgs.append(json.loads(buffer[:position - 1].decode()))  # -1 to remove the \\n, which json.loads won't want\n        buffer = buffer[position:]\n\n    return msgs\n\n\ndef send_fail(message):\n    \"\"\"sends a fail message to the client if an invalid request is sent\"\"\"\n    global sock\n    fail_message = {\n        'src': message['dst'],\n        'dst': message['src'],\n        'leader': message['leader'],\n        'type': 'fail',\n        'MID': message['MID']\n    }\n    send_msg(fail_message)\n\n\ndef restart_election_timeout():\n    \"\"\"Restarts the election timeout of this replica\"\"\"\n\n    global election_timeout, election_timeout_last\n\n    election_timeout = random.randint(150, 300)\n    election_timeout_last = current_milli_time()\n\n\ndef is_atleast_up_to_date(lastLogTermCandidate, lastLogIndexCandidate):\n    \"\"\"Checks if this log is atleast up date compared to another log, but it is given the last log index and term of another log\"\"\"\n    global log\n    lastLogIndex = len(log) - 1 if len(log) > 1 else 0\n    lastLogTerm = log[lastLogIndex]['term'] if len(log) > 1 else 0\n\n    # voter denies vote if its own log is more up to date\n    # log is more up to date if terms are different and its term is larger or if the logs\n    # have the same term and the log is longer\n    if lastLogTerm > lastLogTermCandidate:\n        return False\n    elif lastLogTerm == lastLogTermCandidate and lastLogIndex > lastLogIndexCandidate:\n        return False\n    else:\n        return True\n\n\ndef current_milli_time():\n    \"\"\"Gets the current time in miliseconds\"\"\"\n    return round(time.time() * 1000)\n\n\ndef handle_receiving_request_vote(request_vote_msg):\n    \"\"\"Handles receiving the request to vote\"\"\"\n    global sock, state, states, curr_leader\n\n    restart_election_timeout()\n    curr_leader = \"FFFF\"\n    # only vote if replica is a follower and the leader is unknown\n    if state == FOLLOWER:\n        voteGranted = None\n        # if term of message is less than the current term, do not vote for candidate who sent message\n        if request_vote_msg['term'] < currentTerm:\n            voteGranted = False\n        elif (votedFor is None or votedFor == request_vote_msg['src']) and is_atleast_up_to_date(\n                request_vote_msg['lastLogTerm'], request_vote_msg['lastLogIndex']):\n            # if log is up to date and replica has not voted for anyone this term, vote for candidate\n            if DEBUG:\n                print(request_vote_msg[\"src\"] + \" vote is granted by \" + my_id)\n\n            voteGranted = True\n        # Sending the reply back if the vote if granted\n        if voteGranted:\n            send_request_vote_reply(request_vote_msg, voteGranted)\n\n\ndef handle_receiving_request_vote_reply(request_vote_reply_msg):\n    \"\"\"Handles receiving request vote replies\"\"\"\n    global votesReceived, state, curr_leader, states, queue, nextIndex, matchIndex, replica_ids, log, lastApplied\n\n    # only process a RequestVote response if replica is still a candidate holding an election\n    if state == CANDIDATE:\n        if request_vote_reply_msg['voteGranted']:\n            votesReceived += 1\n\n            if DEBUG:\n                print(str(my_id) + \" has received a vote! You have \" + str(votesReceived) + \" votes!\")\n        if state != LEADER and votesReceived > len(replica_ids) / 2:\n            # restart_election_timeout()\n            # Makes this state the leader and sends a heartbeat right after\n            state = LEADER\n\n            # assume that all requests in this log are committed (WILL PROBABLY BREAK ON DROP)\n            process_log()\n\n            # commitIndex = len(log) - 1 if len(log) > 1 else 0\n            lastApplied = copy.deepcopy(commitIndex)\n\n            # clear previous get responses\n            send_get_responses()\n\n            # Reset nextIndex and matchIndex\n            for replica_id in replica_ids:\n                nextIndex[replica_id] = len(log) if len(log) > 0 else 1\n                matchIndex[replica_id] = 0\n\n            print(\"NEW LEADER----------------------------------------------------------------\")\n            if DEBUG2:\n                print(\"NEW LEADER: NEXT_INDEX = \" + str(nextIndex[replica_ids[-1]]))\n                print(\"MATCH_INDEX = \" + str(matchIndex[replica_ids[-1]]))\n                print(my_id + \" has been chosen as the leader\")\n                print(\"LOG\")\n                print(len(log))\n                print(\"COMMIT INDEX: \" + str(commitIndex))\n\n            # reset number of votes received because replica is no longer holding an election\n            votesReceived = 1\n            # change leader id to replica id, leader is known as self\n            curr_leader = my_id\n            if DEBUG:\n                print(curr_leader)\n\n            send_append_entry([])\n\n            # process all requests received during election/candidate state\n            for entry in queue:\n                if entry not in log and entry['type'] == 'put':\n                    log.append(entry)\n                    # send_append_entry([entry])\n                elif entry['type'] == 'get':\n                    # send_get_response(entry)\n                    process_get(entry)\n\n\n            # empty the queue after processing requests\n            queue.clear()\n\n\ndef send_append_entry(entry):\n    \"\"\"sends a request to vote message\"\"\"\n    global log\n    # index of log entry immediately preceding new ones\n    # if we are committing 1 message at a time, subtract 1 + 1 = 2\n    prevLogIndex = len(log) - 2 if len(log) > 2 else 0\n    # term of prevLogIndex entry\n    prevLogTerm = log[prevLogIndex]['term'] if prevLogIndex > 0 else 0\n\n    append_entry_msg = {\n        'src': my_id,\n        'dst': 'FFFF',\n        'leader': my_id,\n        'type': 'append_entry',\n        'term': currentTerm,\n        'prevLogIndex': prevLogIndex,\n        'prevLogTerm': prevLogTerm,\n        'entries': entry,\n        'leaderCommit': commitIndex\n    }\n\n    if DEBUG:\n        if entry != []:\n            print(\"Sending append entry: \" + str(append_entry_msg))\n    send_msg(append_entry_msg)\n\n\ndef send_append_entry_reply(append_entry_msg):\n    \"\"\"sends a request to vote message\"\"\"\n    global curr_leader, currentTerm, log\n\n\n    append_entry_reply_msg = {\n        'src': my_id,\n        'dst': append_entry_msg['src'],\n        'type': 'append_entry_reply',\n        'leader': curr_leader,\n        'term': currentTerm,\n        # appending entries / replication not fully supported yet, this success is not entirely accurate\n        'success': should_append(append_entry_msg),\n        'matchIndex': len(log) - 1 if len(log) > 1 else 0\n    }\n    send_msg(append_entry_reply_msg)\n\n\n\ndef should_append(append_entry_msg):\n    \"\"\"returns True if the replica should respond True to the AppendEntry RPC received\"\"\"\n    global log, currentTerm\n    # receiver implementation (1): reply false if term < currentTerm\n    if append_entry_msg['term'] < currentTerm:\n        # print(\"MESSAGE TERM WRONG, MSG: \" + str(append_entry_msg['term']) + \" REP: \" + str(currentTerm))\n        return False\n\n    if len(log) < 1 or append_entry_msg['prevLogIndex'] < 1:\n        return True\n    else:\n        try:\n            previousEntry = log[append_entry_msg['prevLogIndex']]\n            # print(\"LOG:\" + str(log))\n            previousEntryTerm = previousEntry['term']\n\n            # receiver implementation (2): reply false if entry at prevLogIndex's term does not match\n            # prevLogTerm\n            if previousEntryTerm != append_entry_msg['prevLogTerm']:\n                # print(\"LOG TERM WRONG: MSG: \" + str(append_entry_msg['prevLogTerm']) + \" REP: \" + str(previousEntryTerm))\n                return False\n            else:\n                return True\n        except IndexError:\n            # receiver implementation (2): reply false if log doesn't contain an entry at prevLogIndex\n            # print(\"PREVIOUS ENTRY NOT HERE: LOG LENGTH = \" + str(len(log)))\n            # print(\"MSG INDEX = \" + str(append_entry_msg['prevLogIndex']))\n            return False\n\n\ndef handle_receiving_append_entry_msg(append_entry_msg):\n    \"\"\"Handles receiving append entry messages\"\"\"\n    global state, states, curr_leader, queue, sock, votesReceived, commitIndex, log, currentTerm, votedFor\n\n    # if a candidate receives an append entry message, revert to follower state\n    if state == CANDIDATE and msg['term'] >= currentTerm:\n        # print(\"CURRENT TERM:\" + str(currentTerm))\n        # print(\"MESSAGE TERM: \" + str(append_entry_msg['term']))\n        # raise ValueError(\"stepping down\")\n\n        if DEBUG:\n            print(\"Stepping down from being a candidate\")\n        state = FOLLOWER\n\n        # reset state variables after falling out of candidate state\n        votesReceived = 1\n        currentTerm = msg['term']\n        votedFor = None\n        curr_leader = msg['leader']\n\n    if should_append(append_entry_msg):\n        restart_election_timeout()\n        # send the queued requests received in candidate state to the appropriate leader\n        for entry in queue:\n            # print(\"SENDING QUEUED ENTRY: \" + str(entry))\n            send_msg(entry)\n\n        # empty the queue after processing requests\n        queue.clear()\n\n        # send any unresponded get requests received in a former leader state to the new leader\n        for index, message in unresponded_gets:\n            send_msg(message)\n        unresponded_gets.clear()\n\n        # receiver implementation (3): if an existing entry conflicts with a new one\n        # (same index but different terms), delete the existing entry and all that follow it\n        if append_entry_msg['prevLogIndex'] < len(log) - 1 and len(log) > 1:\n            for entryIndex in range(len(append_entry_msg['entries'])):\n                # use entries and prevLogIndex to calculate index of entries in leader's log\n                indexInLog = entryIndex + append_entry_msg['prevLogIndex'] + 1\n\n                entryInLog = None\n                try:\n                    entryInLog = log[indexInLog]\n                except IndexError:\n                    break\n\n                # if terms are not equal for an entry with an index in this log, delete entries\n                if entryInLog['term'] != append_entry_msg['entries'][entryIndex]['term']:\n                    while len(log) - 1 >= indexInLog:\n                        log.pop()\n\n                    break\n\n\n        # receiver implementation (4): append any new entries not already in the log\n        # add an empty message to index at 0\n        if len(log) == 0:\n            log.append({'first message': True})\n\n        for entry in append_entry_msg['entries']:\n            if entry not in log and entry['type'] == 'put':\n                log.append(entry)\n\n        # receiver implementation (5): if leaderCommit > commitIndex,\n        # set commitIndex = min(leaderCommit, index of last new entry)\n        if append_entry_msg['leaderCommit'] > commitIndex:\n            commitIndex = min(append_entry_msg['leaderCommit'], len(log) - 1)\n            if DEBUG2:\n                print(\"CHANGED COMMIT INDEX: \" + str(commitIndex))\n\n\n            # apply newly committed messages\n            # apply_messages()\n\n        curr_leader = append_entry_msg['leader']\n\n        # send reply if AppendEntries RPC was not a heartbeat\n        if len(append_entry_msg['entries']) > 0:\n            send_append_entry_reply(append_entry_msg)\n    else:\n        # send reply if AppendEntries RPC was not a heartbeat\n        if len(append_entry_msg['entries']) > 0:\n            send_append_entry_reply(append_entry_msg)\n\n\ndef handle_receiving_append_entry_reply(append_entry_reply):\n    \"\"\"Handles receiving append entry replies\"\"\"\n    global commitIndex, nextIndex, log\n\n    # replication/commits are not fully supported, currently committing all put requests immediately\n    if DEBUG2:\n        print(\"You have received an append entry reply. Message: \" + str(append_entry_reply))\n\n    if append_entry_reply['success'] and state == LEADER:\n        # rules for servers (leader): if successful: update nextIndex and matchIndex for follower\n\n        matchIndex[append_entry_reply['src']] = min(append_entry_reply['matchIndex'], len(log) - 1)\n        nextIndex[append_entry_reply['src']] = copy.deepcopy(matchIndex[append_entry_reply['src']]) + 1\n\n        # if DEBUG2:\n        # print(\"NEXT INDEX: \" + str(nextIndex))\n        # print(\"MATCH INDEX:\" + str(matchIndex))\n        # print(\"LOG: \" + str(len(log)))\n\n        # rules for servers (leader): if there exists an N such that N > commitIndex ...\n        if matchIndex[append_entry_reply['src']] > commitIndex:\n            quorum = 1\n\n            # ... a majority of matchIndex[i] >= N:\n            for replica_id in replica_ids:\n                if matchIndex[replica_id] >= matchIndex[append_entry_reply['src']]:\n                    quorum += 1\n\n            # ... and log[N].term == currentTerm\n\n            if quorum > (len(replica_ids) + 1) / 2 \\\n                    and log[matchIndex[append_entry_reply['src']]]['term'] == currentTerm:\n                commitIndex = copy.deepcopy(matchIndex[append_entry_reply['src']])\n                # print(\"CHANGED COMMIT INDEX: \" + str(commitIndex))\n\n                # apply commits if needed\n                apply_messages()\n\n                # send get responses if possible\n                send_get_responses()\n\n                if DEBUG:\n                    print(\"COMMITTED INDEX \" + str(commitIndex))\n\n    elif not append_entry_reply['success']:\n        # rules for servers (leader): if AppendEntries fails because of log inconsistency: decrement nextIndex and retry\n        nextIndex[append_entry_reply['src']] -= 1\n\n\ndef send_request_vote():\n    \"\"\"sends a RequestVote message to other replicas after starting an election\"\"\"\n    global sock, log, currentTerm, commitIndex\n\n    request_vote_message = {\n        'src': my_id,\n        'dst': 'FFFF',\n        'leader': \"FFFF\",\n        'type': 'request_vote',\n        'term': currentTerm,\n        'lastLogIndex': len(log) - 1 if len(log) > 1 else 0,\n        'lastLogTerm': log[len(log) - 1]['term'] if len(log) > 1 else 0\n    }\n    send_msg(request_vote_message)\n\n\ndef redirect_request(requestMsg):\n    \"\"\"sends a redirect message to the client when a client sends a request to a non-leader replica\"\"\"\n    global sock, curr_leader\n\n    requestMsg['leader'] = curr_leader\n    requestMsg['src'] = my_id\n    requestMsg['dst'] = curr_leader\n    requestMsg['type'] = 'redirect'\n    send_msg(requestMsg)\n\n\ndef send_request_vote_reply(message, voteGranted):\n    \"\"\"sends a RequestVote reply to a candidate who sent a RequestVote message\"\"\"\n    global votedFor, sock, curr_leader, currentTerm\n\n    request_vote_message = {\n        'src': my_id,\n        'dst': message['src'],\n        'type': 'request_vote_reply',\n        'leader': curr_leader,\n        'term': currentTerm,\n        'voteGranted': voteGranted\n    }\n    send_msg(request_vote_message)\n    # record that this replica has already voted for a candidate this term if true\n    if voteGranted:\n        votedFor = request_vote_message['dst']\n\n\ndef start_election():\n    \"\"\" Starts an election. It increments the current term, updates who it voted for to itself, change the state,\n     and sends vote reuqests to the other replicas\"\"\"\n    global state, currentTerm, votedFor, states, curr_leader, votesReceived\n\n    if DEBUG2:\n        print(\"Election started for \" + str(my_id))\n\n    # increment term\n    currentTerm += 1\n    # restart the election timeout\n    restart_election_timeout()\n    # vote for yourself\n    votedFor = my_id\n    # convert to candidate state\n    state = CANDIDATE\n    votesReceived = 1\n\n    curr_leader = \"FFFF\"\n\n    # send RequestVote RPCs to other candidates\n    send_request_vote()\n\n\ndef send_get_response(message):\n    \"\"\"sends a response to the client for a get request\"\"\"\n    global sock, curr_leader, get_mids\n\n    value = \"\"\n    try:\n        value = data[message['key']]\n    except KeyError:\n        # if key does not exist, send a fail message\n        # send_fail(message)\n\n        if DEBUG2:\n            print(\"FAIL\")\n            print(\"STATE: \" + str(data))\n            raise ValueError(\"FAIL\")\n\n    get_response = {\n        'src': my_id,\n        'dst': message['src'],\n        'leader': my_id,\n        'type': 'ok',\n        'MID': message['MID'],\n        'value': value\n    }\n\n    if DEBUG2:\n        # print(\"STATE\")\n        # print(data)\n        pass\n\n    most_recent_result = \"\"\n    for log_entry in log[1:]:\n        if log_entry['type'] == 'put' and log_entry['key'] == message['key']:\n            most_recent_result = log_entry['value']\n\n    if most_recent_result != get_response['value']:\n        warn(\"get response sent before the necessary put was committed\")\n        # warn(\"get message: \" + str(message))\n        warn(\"log :\" + str(log))\n        warn(\"response should be \" + most_recent_result)\n\n    # print(\"RESPONSE\")\n    # print(get_response)\n\n    send_msg(get_response)\n\n\ndef send_put_response(message):\n    \"\"\"sends a response to the client for a put request\"\"\"\n    global sock, curr_leader\n\n    put_response = {\n        'src': my_id,\n        'dst': message['src'],\n        'leader': my_id,\n        'type': 'ok',\n        'MID': message['MID'],\n    }\n\n    if DEBUG2:\n        # print(\"STATE\")\n        # print(data)\n        pass\n    # print(\"RESPONSE\")\n    # print(put_response['MID'])\n    send_msg(put_response)\n\n\ndef send_redirect(message):\n    \"\"\"sends a redirect message to the client (when replica is not the leader and receives a request)\"\"\"\n    global sock, curr_leader\n\n    redirect = {\n        'src': my_id,\n        'dst': message['src'],\n        'leader': curr_leader,\n        'type': 'redirect',\n        'MID': message['MID']\n    }\n\n    if DEBUG:\n        print(redirect)\n    send_msg(redirect)\n\n\ndef process_request(message):\n    \"\"\"applies a client request as if this replica is the leader\"\"\"\n    if message['type'] == 'put':\n        data[message['key']] = message['value']\n\n        if state == LEADER and original_request(message):\n            send_put_response(message)\n\n\ndef apply_messages():\n    \"\"\"applies messages that have been recently committed\"\"\"\n    global lastApplied, log\n\n    # rules for servers (all servers): if commitIndex > lastApplied: increment lastApplied,\n    # apply log[lastApplied] to state machine\n    while commitIndex > lastApplied:\n        lastApplied += 1\n\n        process_request(log[lastApplied])\n\n\ndef send_append_entries():\n    \"\"\"sends the appropriate AppendEntries RPC to each replica\"\"\"\n    # index of log entry immediately preceding new ones\n    # if we are committing 1 message at a time, subtract 1 + 1 = 2\n    prevLogIndex = len(log) - 2 if len(log) > 2 else 0\n    # term of prevLogIndex entry\n    prevLogTerm = log[prevLogIndex]['term'] if prevLogIndex > 0 else 0\n    entries = []\n\n    append_entry_msg = {\n        'src': my_id,\n        'dst': 'FFFF',\n        'leader': my_id,\n        'type': 'append_entry',\n        'term': currentTerm,\n        'prevLogIndex': prevLogIndex,\n        'prevLogTerm': prevLogTerm,\n        'entries': entries,\n        'leaderCommit': commitIndex\n    }\n\n    if DEBUG2:\n        print(\"LOG: \" + str(len(log)))\n    # if there are messages to send, send them, if not, send heartbeat\n    for replica_id in replica_ids:\n        append_entry_msg['dst'] = replica_id\n        append_entry_msg['prevLogIndex'] = nextIndex[replica_id] - 1 if nextIndex[replica_id] > 1 else 0\n        append_entry_msg['prevLogTerm'] = log[append_entry_msg['prevLogIndex']]['term'] if nextIndex[replica_id] > 1 else 0\n\n        # 0 1 2 + 3 4\n        # nextIndex = 3\n        if len(log) - 1 >= nextIndex[replica_id]:\n            append_entry_msg['entries'] = log[nextIndex[replica_id]:]\n            # print(\"SENDING APPEND ENTRIES RPC FROM \" + my_id + \" TO \" + replica_id + \"(\" + str(len(append_entry_msg['entries'])) + \")\")\n        else:\n            pass\n            # print(\"SENDING HEARTBEAT FROM \" + my_id + \" TO \" + replica_id)\n        send_msg(append_entry_msg)\n\ndef equal_requests(request1, request2):\n    \"\"\"returns True if the requests are the same except for MID\"\"\"\n    try:\n        request1NoMID = copy.deepcopy(request1)\n        del request1NoMID['MID']\n\n        request2NoMID = copy.deepcopy(request2)\n        del request2NoMID['MID']\n\n        return request1NoMID == request2NoMID\n    except KeyError:\n        return False\n\ndef original_request(request):\n    \"\"\"returns true if this request requires a new action to be taken\"\"\"\n    global log\n\n    count_duplicates = 0\n\n    for log_request in log[:commitIndex]:\n        try:\n            if log_request['MID'] == request['MID']:\n                count_duplicates += 1\n        except KeyError:\n            pass\n\n    if count_duplicates <= 1:\n        return True\n    else:\n        # raise ValueError(\"DUPLICATE FOUND\")\n        return False\n\n\ndef process_log():\n    \"\"\"converts log to state machine for a newly elected leader\"\"\"\n    global data\n    data.clear()\n\n    if len(log) > 1:\n        for request_index in range(1, commitIndex + 1):\n            request = log[request_index]\n            data[request['key']] = request['value']\n\n            # if request_index > commitIndex:\n            #     send_put_response(request)\n\ndef send_get_responses():\n    \"\"\"sends get responses if the appropriate number of commits is reached\"\"\"\n    requests_to_remove = []\n\n    for lastPutIndex, get_request in unresponded_gets:\n        # if the last put request before the get was committed, send a get response\n        if commitIndex >= lastPutIndex:\n            send_get_response(get_request)\n            requests_to_remove.append((lastPutIndex, get_request))\n\n    # remove responded get requests from list of unresponded gets\n    for request_to_remove in requests_to_remove:\n        unresponded_gets.remove(request_to_remove)\n\n\ndef should_send_get_response(get_request):\n    \"\"\"returns True if the latest put in this get request has been committed\"\"\"\n    if getLastPutIndex(get_request) is None:\n        return True\n    else:\n        lastPutRequest = log[getLastPutIndex(get_request)]\n        try:\n            return lastPutRequest['value'] == data[get_request['key']]\n        except KeyError:\n            warn(\"blank response incoming for get request \" + str(get_request))\n            return False\n\ndef getLastPutIndex(get_request):\n    \"\"\"retrieves the index of the last put request with the same key as that of a get request\"\"\"\n    if len(log) > 1:\n        for log_index in range(len(log) - 1, 0, -1):\n            log_entry = log[log_index]\n            if log_entry['type'] == 'put' and log_entry['key'] == get_request['key']:\n                return log_index\n\n    return None\n\n\ndef process_get(get_request):\n    \"\"\"sends a get response to the given request if all put requests with the given key have been applied\"\"\"\n    if should_send_get_response(get_request):\n        send_get_response(get_request)\n    elif getLastPutIndex(get_request) is not None:\n        unresponded_gets.append((getLastPutIndex(get_request), get_request))\n    else:\n        send_fail()\n\n\ndef send_msg(msg):\n    global sock\n    ready2 = select.select([], [sock], [],SELECT_WAIT_TIME)[1]\n    if sock in ready2:\n        sock.send(json.dumps(msg).encode() + b'\\n')\nwhile True:\n    ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]\n\n    if sock in ready:\n        msgs = recv_msgs()\n\n        for msg in msgs:\n\n            if msg['type'] in ['request_vote', 'request_vote_reply', 'append_entry', 'append_entry_reply']:\n                # HANDLING RPCS\n\n                # Update the current term if the message's term is higher than the replica's term\n                if msg['term'] > currentTerm:\n                    currentTerm = msg['term']\n                    votedFor = None\n                    state = FOLLOWER\n                    curr_leader = msg['leader']\n                    votesReceived = 1\n                # if state == FOLLOWER or state != LEADER and msg['type'] != 'request_vote':\n                    # Restart election timer if not a leader\n                    # if DEBUG:\n                    #     print('Restarted election timeout for ' + str(my_id) + '. Election timeout is now: ' + str(\n                    #         election_timeout) + 'ms')\n                    # restart_election_timeout()\n                if msg['type'] == 'request_vote':\n                    handle_receiving_request_vote(msg)\n                elif msg['type'] == 'request_vote_reply':\n                    handle_receiving_request_vote_reply(msg)\n                elif msg['type'] == 'append_entry':\n                    handle_receiving_append_entry_msg(msg)\n                elif msg['type'] == 'append_entry_reply':\n                    handle_receiving_append_entry_reply(msg)\n            elif msg['type'] in ['get', 'put']:\n                # add term to this message\n                msg['term'] = currentTerm\n\n                # if msg['type'] == 'get':\n                #     raise ValueError(\"GET RECEIVED\")\n\n                # HANDLING CLIENT REQUESTS\n                # if DEBUG2:\n                # print(\"REQUEST\")\n                # print(msg)\n\n                if curr_leader == \"FFFF\":\n                    if DEBUG2:\n                        print(\"There is no current leader, we are appending the message to the queue\")\n                    # if current leader is unknown, the replica is in candidate stage and cannot process requests.\n                    # add requests to a buffer to be processed later when the leader is known\n                    if msg not in queue:\n                        queue.append(msg)\n\n                elif curr_leader == my_id:\n                    if DEBUG:\n                        print(\"Handling messages that are queued\")\n\n                    # add first message\n                    if len(log) == 0:\n                        log.append({\"first message\": True})\n\n                    # process get requests right away, store put requests in log\n                    if msg['type'] == 'get':\n                        # send_get_response(msg)\n                        process_get(msg)\n                    elif msg not in log:\n                        log.append(msg)\n\n\n                    # if the replica is the leader, send AppendEntries RPC to replicas\n                    # send_append_entry([msg])\n                    send_append_entries()\n                else:\n                    # print(\"Redirecting request to \" + str(curr_leader))\n                    # print(my_id)\n                    # print(curr_leader)\n\n                    # if the replica is a follower and the leader is known, then redirect the request to the leader\n                    send_redirect(msg)\n\n    curr_time = current_milli_time()\n    if state != LEADER and curr_time - election_timeout_last > election_timeout:\n        # if election timeout has expired and the replica is not a leader, start an election\n        start_election()\n    if state == LEADER and curr_time - heartbeat_last > 140:\n        # if the heartbeat timeout has expired (140 ms) and the replica is a leader, send another heartbeat message\n        # send_append_entry([])\n\n        send_append_entries()\n\n        if DEBUG:\n            print(\"Sent heartbeat\")\n\n        heartbeat_last = curr_timeicates"     : [0, 6, 20],
            "median_latency" : [0.0002, 0.005, 0.1]
        }
    },
    "maximum_get_generation_fail_fraction" : 0.2
}
